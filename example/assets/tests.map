{"version":3,"sources":["vendor/ember-cli/tests-prefix.js","ember-tooltip-example/tests/app.lint-test.js","ember-tooltip-example/tests/helpers/ember-tooltips.js","ember-tooltip-example/tests/test-helper.js","ember-tooltip-example/tests/tests.lint-test.js","vendor/ember-cli/app-config.js","vendor/ember-cli/tests-suffix.js"],"sourcesContent":["'use strict';\n","define('ember-tooltip-example/tests/app.lint-test', [], function () {\n  'use strict';\n\n  QUnit.module('ESLint | app');\n\n  QUnit.test('app.js', function (assert) {\n    assert.expect(1);\n    assert.ok(true, 'app.js should pass ESLint\\n\\n');\n  });\n\n  QUnit.test('resolver.js', function (assert) {\n    assert.expect(1);\n    assert.ok(true, 'resolver.js should pass ESLint\\n\\n');\n  });\n\n  QUnit.test('router.js', function (assert) {\n    assert.expect(1);\n    assert.ok(true, 'router.js should pass ESLint\\n\\n');\n  });\n});","define('ember-tooltip-example/tests/helpers/ember-tooltips', ['exports'], function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.findTooltip = findTooltip;\n  exports.findTooltipTarget = findTooltipTarget;\n  exports.triggerTooltipTargetEvent = triggerTooltipTargetEvent;\n  exports.assertTooltipNotRendered = assertTooltipNotRendered;\n  exports.assertTooltipRendered = assertTooltipRendered;\n  exports.assertTooltipNotVisible = assertTooltipNotVisible;\n  exports.assertTooltipVisible = assertTooltipVisible;\n  exports.assertTooltipSide = assertTooltipSide;\n  exports.assertTooltipSpacing = assertTooltipSpacing;\n  exports.assertTooltipContent = assertTooltipContent;\n  exports.afterTooltipRenderChange = afterTooltipRenderChange;\n\n\n  const {\n    $,\n    run\n  } = Ember;\n\n  const TOOLTIP_SELECTOR = '.ember-tooltip, .ember-popover';\n  const TARGET_SELECTOR = '.ember-tooltip-target, .ember-popover-target';\n\n  /**\n  @method getPositionDifferences\n  @param String side The side the tooltip should be on relative to the target\n  \n  Given a side, which represents the side of the target that\n  the tooltip should render, this method identifies whether\n  the tooltip or the target should be further away from the\n  top left of the window.\n  \n  For example, if the side is 'top' then the target should\n  be further away from the top left of the window than the\n  tooltip because the tooltip should render above the target.\n  \n  If the side is 'right' then the tooltip should be further\n  away from the top left of the window than the target\n  because the tooltip should render to the right of the\n  target.\n  \n  This method then returns an object with two numbers:\n  \n  - `expectedGreaterDistance` (expected greater number given the side)\n  - `expectedLesserDistance` (expected lesser number given the side)\n  \n  These numbers can be used for calculations like determining\n  whether a tooltip is on the correct side of the target or\n  determining whether a tooltip is the correct distance from\n  the target on the given side.\n  */\n\n  function getPositionDifferences(options = {}) {\n    const { targetPosition, tooltipPosition } = getTooltipAndTargetPosition(options);\n    const { side } = options;\n\n    const distanceToTarget = targetPosition[side];\n    const distanceToTooltip = tooltipPosition[getOppositeSide(side)];\n    const shouldTooltipBeCloserThanTarget = side === 'top' || side === 'left';\n    const expectedGreaterDistance = shouldTooltipBeCloserThanTarget ? distanceToTarget : distanceToTooltip;\n    const expectedLesserDistance = shouldTooltipBeCloserThanTarget ? distanceToTooltip : distanceToTarget;\n\n    return { expectedGreaterDistance, expectedLesserDistance };\n  }\n\n  function getTooltipFromBody(selector = TOOLTIP_SELECTOR) {\n    // we have to .find() tooltips from $body because sometimes\n    // tooltips and popovers are rendered as children of <body>\n    // instead of children of the $targetElement\n\n    const $body = $(document.body);\n    const $tooltip = $body.find(selector);\n\n    if ($tooltip.length === 0) {\n      throw Error('getTooltipFromBody(): No tooltips were found.');\n    } else if (!$tooltip.hasClass('ember-tooltip') && !$tooltip.hasClass('ember-popover')) {\n      throw Error(`getTooltipFromBody(): returned an element that is not a tooltip`);\n    } else if ($tooltip.length > 1) {\n      throw Error('getTooltipFromBody(): Multiple tooltips were found. Please provide an {option.selector = \".specific-tooltip-class\"}');\n    }\n\n    return $tooltip;\n  }\n\n  function getTooltipTargetFromBody(selector = TARGET_SELECTOR) {\n    const $body = $(document.body);\n    const $tooltipTarget = $body.find(selector);\n\n    if ($tooltipTarget.length === 0) {\n      throw Error('getTooltipTargetFromBody(): No tooltip targets were found.');\n    } else if ($tooltipTarget.length > 1) {\n      throw Error('getTooltipTargetFromBody(): Multiple tooltip targets were found. Please provide an {option.targetSelector = \".specific-tooltip-target-class\"}');\n    }\n\n    return $tooltipTarget;\n  }\n\n  function getOppositeSide(side) {\n    switch (side) {\n      case 'top':\n        return 'bottom';break;\n      case 'right':\n        return 'left';break;\n      case 'bottom':\n        return 'top';break;\n      case 'left':\n        return 'right';break;\n    }\n  }\n\n  function validateSide(side, testHelper = 'assertTooltipSide') {\n    const sideIsValid = side === 'top' || side === 'right' || side === 'bottom' || side === 'left';\n\n    /* We make sure the side being tested is valid. We\n    use Ember.assert because assert is passed in from QUnit */\n\n    if (!sideIsValid) {\n      Ember.assert(`You must pass side like ${testHelper}(assert, { side: 'top' }); Valid options for side are top, right, bottom, and left.`);\n    }\n  }\n\n  function getTooltipAndTargetPosition(options = {}) {\n    const $target = getTooltipTargetFromBody(options.targetSelector || TARGET_SELECTOR);\n    const targetPosition = $target[0].getBoundingClientRect();\n    const $tooltip = getTooltipFromBody(options.selector || TOOLTIP_SELECTOR);\n    const tooltipPosition = $tooltip[0].getBoundingClientRect();\n\n    return {\n      targetPosition,\n      tooltipPosition\n    };\n  }\n\n  /* TODO(Duncan): Document */\n\n  function findTooltip(selector = TOOLTIP_SELECTOR) {\n    return getTooltipFromBody(selector);\n  }\n\n  /* TODO(Duncan): Document */\n\n  function findTooltipTarget(selector = TARGET_SELECTOR) {\n    return getTooltipTargetFromBody(selector);\n  }\n\n  /* TODO(Duncan):\n  \n  Update triggerTooltipTargetEvent() to use getTooltipTargetFromBody\n  and move side into the options hash */\n\n  function triggerTooltipTargetEvent($element, type, options = {}) {\n\n    const approvedEventTypes = ['mouseenter', 'mouseleave', 'click', 'focus', 'focusin', 'focusout', 'blur'];\n\n    if (approvedEventTypes.indexOf(type) == -1) {\n      throw Error(`only ${approvedEventTypes.join(', ')} will trigger a tooltip event. You used ${type}.`);\n    }\n\n    if (options.selector) {\n      $element = getTooltipTargetFromBody(options.selector);\n    }\n\n    /* If the $tooltip is hidden then the user can't interact with it */\n\n    if ($element.attr('aria-hidden') === 'true') {\n      return;\n    }\n\n    run(() => {\n      $element[0].dispatchEvent(new window.Event(type));\n    });\n  }\n\n  function assertTooltipNotRendered(assert, options = {}) {\n    const $body = $(document.body);\n    const $tooltip = $body.find(options.selector || TOOLTIP_SELECTOR);\n\n    assert.equal($tooltip.length, 0, 'assertTooltipNotRendered(): the ember-tooltip should not be rendered');\n  }\n\n  function assertTooltipRendered(assert, options = {}) {\n    const $tooltip = getTooltipFromBody(options.selector);\n\n    assert.equal($tooltip.length, 1, 'assertTooltipRendered(): the ember-tooltip should be rendered');\n  }\n\n  function assertTooltipNotVisible(assert, options = {}) {\n    const $tooltip = getTooltipFromBody(options.selector);\n    const ariaHidden = $tooltip.attr('aria-hidden');\n\n    assert.ok(ariaHidden === 'true', `assertTooltipNotVisible(): the ember-tooltip shouldn't be visible:\n      aria-hidden = ${ariaHidden}`);\n  }\n\n  function assertTooltipVisible(assert, options = {}) {\n    const $tooltip = getTooltipFromBody(options.selector);\n    const ariaHidden = $tooltip.attr('aria-hidden');\n\n    assert.ok(ariaHidden === 'false', `assertTooltipVisible(): the ember-tooltip should be visible:\n      aria-hidden = ${ariaHidden}`);\n  }\n\n  function assertTooltipSide(assert, options = {}) {\n    const { side } = options;\n\n    validateSide(side);\n\n    const { expectedGreaterDistance, expectedLesserDistance } = getPositionDifferences(options);\n\n    /* When the side is top or left, the greater number\n    is the target's position. Thus, we check that the\n    target's position is greater than the tooltip's\n    position. */\n\n    assert.ok(expectedGreaterDistance > expectedLesserDistance, `Tooltip should be on the ${side} side of the target`);\n  }\n\n  function assertTooltipSpacing(assert, options) {\n    const { side, spacing } = options;\n\n    validateSide(side, 'assertTooltipSpacing');\n\n    if (typeof spacing !== 'number') {\n      Ember.assert(`You must pass spacing as a number like assertTooltipSpacing(assert, { side: 'top', spacing: 10 });`);\n    }\n\n    const { expectedGreaterDistance, expectedLesserDistance } = getPositionDifferences(options);\n    const actualSpacing = Math.round(expectedGreaterDistance - expectedLesserDistance);\n\n    /* When the side is top or left, the greater number\n    is the target's position. Thus, we check that the\n    target's position is greater than the tooltip's\n    position. */\n\n    const isSideCorrect = expectedGreaterDistance > expectedLesserDistance;\n    const isSpacingCorrect = actualSpacing === spacing;\n\n    assert.ok(isSideCorrect && isSpacingCorrect, `assertTooltipSpacing(): the tooltip should be in the correct position:\n        - Tooltip should be on the ${side} side of the target: ${isSideCorrect}.\n        - On the ${side} side of the target, the tooltip should be ${spacing}px from the target but it was ${actualSpacing}px`);\n  }\n\n  function assertTooltipContent(assert, options = {}) {\n    const { contentString } = options;\n\n    if (Ember.isNone(contentString)) {\n      Ember.assert('You must specify a contentString property in the options parameter');\n    }\n\n    const $tooltip = getTooltipFromBody(options.selector);\n    const tooltipContent = $tooltip.text().trim();\n\n    assert.equal(tooltipContent, contentString, `Content of tooltip (${tooltipContent}) matched expected (${contentString})`);\n  }\n\n  function afterTooltipRenderChange(assert, callback, delay = 0) {\n\n    if (!assert.async) {\n      console.warn('Did you forget to pass assert as the first param to afterTooltipRenderChange?');\n    }\n\n    const done = assert.async();\n\n    run.later(() => {\n      callback();\n      done();\n    }, delay);\n  }\n});","define('ember-tooltip-example/tests/test-helper', ['ember-tooltip-example/app', 'ember-tooltip-example/config/environment', '@ember/test-helpers', 'ember-qunit'], function (_app, _environment, _testHelpers, _emberQunit) {\n  'use strict';\n\n  (0, _testHelpers.setApplication)(_app.default.create(_environment.default.APP));\n\n  (0, _emberQunit.start)();\n});","define('ember-tooltip-example/tests/tests.lint-test', [], function () {\n  'use strict';\n\n  QUnit.module('ESLint | tests');\n\n  QUnit.test('test-helper.js', function (assert) {\n    assert.expect(1);\n    assert.ok(true, 'test-helper.js should pass ESLint\\n\\n');\n  });\n});","define('ember-tooltip-example/config/environment', [], function() {\n  var prefix = 'ember-tooltip-example';\ntry {\n  var metaName = prefix + '/config/environment';\n  var rawConfig = document.querySelector('meta[name=\"' + metaName + '\"]').getAttribute('content');\n  var config = JSON.parse(unescape(rawConfig));\n\n  var exports = { 'default': config };\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n}\ncatch(err) {\n  throw new Error('Could not read config from meta tag with name \"' + metaName + '\".');\n}\n\n});\n","require('ember-tooltip-example/tests/test-helper');\nEmberENV.TESTS_FILE_LOADED = true;\n"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/QA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;","file":"tests.js"}